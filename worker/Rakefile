# Rakefile for worker, provides handiful functions for controlling worker module.
#
# Author::  Santa Zhang (santa1987@gmail.com)
# Since::   0.3


# Add your own tasks in files placed in lib/tasks ending in .rake,
# for example lib/tasks/capistrano.rake, and they will automatically be available to Rake.

require(File.join(File.dirname(__FILE__), 'config', 'boot'))

require 'rake'
require 'rake/testtask'
require 'rake/rdoctask'

require 'tasks/rails'

require "#{File.dirname __FILE__}/../common/lib/utils.rb"
require 'fileutils'
require 'yaml'

namespace :nova do
  namespace :worker do

    # Read common YAML config.
    #
    # Since::     0.3
    def read_config
      conf = YAML::load File.read "#{RAILS_ROOT}/../common/config/conf.yml"
    end

    # Initialize system, create database, loads default values.
    #
    # Since::     0.3
    def do_init
      require_root_privilege
      puts "Building helper tools.."
      my_exec "cd #{RAILS_ROOT}/lib && make"
      puts "Migrating database..."
      my_exec "rake db:migrate RAILS_ENV=production"
      my_exec "rake db:migrate RAILS_ENV=development"
      my_exec "rake db:migrate:reset RAILS_ENV=production"
      my_exec "rake db:migrate:reset RAILS_ENV=development"
      puts "Loading data..."
      my_exec "rake db:fixtures:load RAILS_ENV=production"
      my_exec "rake db:fixtures:load RAILS_ENV=development"
    end

    desc "Initialize system"
    task :init do
      do_init
    end

    def do_start
      require_root_privilege  # we must run worker as "root", since we will connect to "qemu:///system", which is privileged action

      conf = read_config
      service_port = conf["worker_port"]
      puts "Writing hostname into tmp/hostname..."
      FileUtils.mkdir_p "#{RAILS_ROOT}/tmp"
      my_exec "hostname > #{RAILS_ROOT}/tmp/hostname"
      puts "Starting Nova worker on port #{service_port}..."

      FileUtils.mkdir_p conf["run_root"]
      File.open("#{conf["run_root"]}/ftp_server_files_list_updater_lftp_script", "w") do |f|
        f.write <<LFTP_SCRIPT
set net:max-retries 2
set net:reconnect-interval-base 1
open #{File.read "#{RAILS_ROOT}/config/storage_server.conf"}
pwd
ls
LFTP_SCRIPT
      end

      my_exec "#{RAILS_ROOT}/lib/ftp_server_files_list_updater #{RAILS_ROOT}/tmp/pids/ftp_server_files_list_updater.pid #{conf["run_root"]}"
      my_exec "#{RAILS_ROOT}/lib/image_pool_maintainer #{RAILS_ROOT}/tmp/pids/image_pool_maintainer.pid #{RAILS_ROOT}/lib/image_pool_maintainer.conf #{conf["run_root"]}/image_pool"
      my_exec "#{RAILS_ROOT}/lib/trash_cleaner #{RAILS_ROOT}/tmp/pids/trash_cleaner.pid #{conf["run_root"]}"
      my_exec "#{RAILS_ROOT}/script/server -d -p #{service_port}"
    end

    desc "Start Nova worker"
    task :start do
      do_start
    end

    def do_stop
      require_root_privilege  # worker is started using root privilege, so we have to kill it using root privilege

      Dir.foreach("#{RAILS_ROOT}/tmp/pids") do |entry|
        next if (entry.end_with? ".pid") == false
        kill_by_pid_file "#{RAILS_ROOT}/tmp/pids/#{entry}"
      end

      if File.exists? "#{RAILS_ROOT}/tmp/hostname"
        FileUtils.rm "#{RAILS_ROOT}/tmp/hostname"
      end
    end

    desc "Stop Nova worker"
    task :stop do
      do_stop
    end

    desc "Reset system, remove all Vmachines, cleanup all resource"
    task :reset do
      require_root_privilege

      require 'rubygems'
      require 'libvirt'
      
      my_exec "Rake nova:worker:stop"

      virt_conn = Libvirt::open("qemu:///system")
      virt_conn.list_defined_domains.each do |domain_name|
        puts "Destroying domain '#{domain_name}'"
        begin
          dom = virt_conn.lookup_domain_by_name domain_name
          puts "UUID=#{dom.uuid}"
          begin
            dom.destroy
          rescue
            # do nothing here
          end
          dom.undefine
        rescue
          next
        end
      end

      # TODO cleanup resource

      do_init
      do_stop
      do_start
    end
  end
end

