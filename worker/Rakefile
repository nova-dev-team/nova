# Rakefile for worker, provides handiful functions for controlling worker module.
#
# Author::  Santa Zhang (santa1987@gmail.com)
# Since::   0.3


# Add your own tasks in files placed in lib/tasks ending in .rake,
# for example lib/tasks/capistrano.rake, and they will automatically be available to Rake.

require(File.join(File.dirname(__FILE__), 'config', 'boot'))

require 'rake'
require 'rake/testtask'
require 'rake/rdoctask'

require 'tasks/rails'

require "#{File.dirname __FILE__}/../common/lib/utils.rb"
require 'fileutils'
require 'yaml'

namespace :nova do
  namespace :worker do

    # Make sure all folders are ready.
    #
    # Since::     0.3
    def prepare_folders
      FileUtils.mkdir_p "#{RAILS_ROOT}/log"
      FileUtils.mkdir_p "#{RAILS_ROOT}/tmp/pids"
    end

    # Read common YAML config.
    #
    # Since::     0.3
    def read_config
      conf = YAML::load File.read "#{RAILS_ROOT}/../common/config/conf.yml"
    end

    # Initialize system, create database, loads default values.
    #
    # Since::     0.3
    def do_init
      prepare_folders
      require_root_privilege
      puts "Building helper tools.."
      puts "Migrating database..."
      my_exec "rake db:migrate RAILS_ENV=production"
      my_exec "rake db:migrate RAILS_ENV=development"
      my_exec "rake db:migrate:reset RAILS_ENV=production"
      my_exec "rake db:migrate:reset RAILS_ENV=development"
      puts "Loading data..."
      my_exec "rake db:fixtures:load RAILS_ENV=production"
      my_exec "rake db:fixtures:load RAILS_ENV=development"
    end

    desc "Initialize system"
    task :init do
      do_init
    end

    def do_start
      prepare_folders
      require_root_privilege  # we must run worker as "root", since we will connect to "qemu:///system", which is privileged action
      my_exec "cd #{RAILS_ROOT}/lib && make" # make sure newest binary are used
      conf = read_config

      # check if the port is being used by others
      p = IO.popen "lsof -i tcp:#{conf["worker_port"]}"
      lsof_out = p.readlines
      if lsof_out.length > 1
        puts "!!! The port #{conf["worker_port"]} is occupied by the folloing processes:"
        print lsof_out
        puts "!!! Please kill those processes before continue!\n"
        exit
      end
      p.close

      my_exec "modprobe kvm_intel"
      my_exec "modprobe kvm_amd"

      # make sure libvirtd is running
      my_exec "service libvirt-bin start"

      # make sure there is network bridge
      my_exec "./lib/create_br.rb"

      service_port = conf["worker_port"]
      puts "Writing hostname into tmp/hostname..."
      FileUtils.mkdir_p "#{RAILS_ROOT}/tmp"
      my_exec "hostname > #{RAILS_ROOT}/tmp/hostname"
      puts "Starting Nova worker on port #{service_port}..."

      FileUtils.mkdir_p "#{conf["run_root"]}/vm"
      FileUtils.mkdir_p "#{conf["run_root"]}/image_pool"

      unless File.exists? "#{RAILS_ROOT}/config/storage_server.conf"
        puts "!!!"
        puts "!!! You haven't initialized the worker module!"
        puts "!!! run 'rake nova:worker:init' first!"
        puts "!!!"
        exit
      end

      File.open("#{conf["run_root"]}/ftp_server_files_list_updater_lftp_script", "w") do |f|
        f.write <<LFTP_SCRIPT
set net:timeout 10
set net:max-retries 2
set net:reconnect-interval-base 1
open #{File.read "#{RAILS_ROOT}/config/storage_server.conf"}
cd /vdisks
pwd
ls
cd /agent_packages
pwd
ls
LFTP_SCRIPT
      end

      my_exec "#{RAILS_ROOT}/lib/ftp_server_files_list_updater #{RAILS_ROOT}/tmp/pids/ftp_server_files_list_updater.pid #{conf["run_root"]}"
      my_exec "#{RAILS_ROOT}/lib/image_pool_maintainer #{RAILS_ROOT}/tmp/pids/image_pool_maintainer.pid #{RAILS_ROOT}/lib/image_pool_maintainer.conf #{conf["run_root"]}/image_pool"
      my_exec "#{RAILS_ROOT}/lib/trash_cleaner #{RAILS_ROOT}/log #{conf["run_root"]}"
      my_exec "RAILS_ENV=development #{RAILS_ROOT}/script/server -d -p #{service_port} &"
    end

    desc "Start Nova worker"
    task :start => :stop do
      do_start
    end

    def do_stop
      prepare_folders
      require_root_privilege  # worker is started using root privilege, so we have to kill it using root privilege

      conf = read_config
      # remove temp helper files
      FileUtils.rm_f "#{conf["run_root"]}/ftp_server_files_list_updater_lftp_script"
      FileUtils.rm_f "#{conf["run_root"]}/ftp_server_files_list~"
      FileUtils.rm_f "#{conf["run_root"]}/ftp_server_files_list"

      Dir.foreach("#{RAILS_ROOT}/tmp/pids") do |entry|
        next if (entry.end_with? ".pid") == false
        kill_by_pid_file "#{RAILS_ROOT}/tmp/pids/#{entry}"
      end

      Dir.foreach("#{RAILS_ROOT}/log") do |entry|
        next if (entry.end_with? ".pid") == false
        kill_by_pid_file "#{RAILS_ROOT}/log/#{entry}"
      end

      if File.exists? "#{RAILS_ROOT}/tmp/hostname"
        FileUtils.rm "#{RAILS_ROOT}/tmp/hostname"
      end

      # shutdown libvirt
      my_exec "stop libvirt-bin"
    end

    desc "Stop Nova worker"
    task :stop do
      do_stop
    end

    desc "Reset system, remove all Vmachines, cleanup all resource"
    task :reset do
      require_root_privilege

      require 'rubygems'
      require 'libvirt'
      
      my_exec "Rake nova:worker:stop"

      virt_conn = Libvirt::open("qemu:///system")
      virt_conn.list_defined_domains.each do |domain_name|
        puts "Destroying domain '#{domain_name}'"
        begin
          dom = virt_conn.lookup_domain_by_name domain_name
          puts "UUID=#{dom.uuid}"
          begin
            dom.destroy
          rescue
            # do nothing here
          end
          dom.undefine
        rescue
          next
        end
      end

      # TODO cleanup resource

      do_init
      do_stop
    end
  end
end

