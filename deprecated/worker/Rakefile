# Rakefile for worker, provides handiful functions for controlling worker module.
#
# Author::  Santa Zhang (santa1987@gmail.com)
# Since::   0.3


# Add your own tasks in files placed in lib/tasks ending in .rake,
# for example lib/tasks/capistrano.rake, and they will automatically be available to Rake.

require(File.join(File.dirname(__FILE__), 'config', 'boot'))

require 'rake'
require 'rake/testtask'
require 'rake/rdoctask'

require 'tasks/rails'
require 'uuidtools'

require "#{File.dirname __FILE__}/lib/utils.rb"
require 'fileutils'
require 'yaml'

namespace :nova do
  namespace :worker do

    # Make sure all folders are ready.
    #
    # Since::     0.3
    def prepare_folders
      FileUtils.mkdir_p "#{RAILS_ROOT}/log"
      FileUtils.mkdir_p "#{RAILS_ROOT}/tmp/pids"
    end

    # Read common YAML config.
    #
    # Since::     0.3
    def read_config
      conf = common_conf
    end

    # Initialize system, create database, loads default values.
    #
    # Since::     0.3
    def do_init
      prepare_folders
      require_root_privilege
      puts "Building helper tools.."
      puts "Migrating database..."
      my_exec "rake db:migrate RAILS_ENV=production"
      my_exec "rake db:migrate RAILS_ENV=development"
      my_exec "rake db:migrate:reset RAILS_ENV=production"
      my_exec "rake db:migrate:reset RAILS_ENV=development"
      puts "Loading data..."
      my_exec "rake db:fixtures:load RAILS_ENV=production"
      my_exec "rake db:fixtures:load RAILS_ENV=development"
      my_exec "echo \"#{UUIDTools::UUID.random_create.to_s}\" > config/worker.uuid"
    end

    desc "Initialize system"
    task :init do
      do_init
    end

    def do_start
      prepare_folders
      require_root_privilege  # we must run worker as "root", since we will connect to "qemu:///system", which is privileged action
      my_exec "cd #{RAILS_ROOT}/lib && make" # make sure newest binary are used
      conf = read_config

      # check if the port is being used by others
      p = IO.popen "lsof -i tcp:#{conf["worker_port"]}"
      lsof_out = p.readlines
      if lsof_out.length > 1
        puts "!!! The port #{conf["worker_port"]} is occupied by the folloing processes:"
        print lsof_out
        puts "!!! Please kill those processes before continue!\n"
        exit
      end
      p.close

      my_exec "modprobe kvm_intel"
      my_exec "modprobe kvm_amd"

      # make sure libvirtd is running
      my_exec "service libvirt-bin start"

      if conf["hypervisor"] == "kvm"
        if conf["vm_network_interface"] != nil and conf["vm_network_bridge"] != nil
          # if using kvm, we need to create the network bridge
          # make sure there is network bridge
          my_exec "./lib/create_br.rb"
        else
          puts "use NAT for vm network"
        end
      else
        # in CentOS5.4 Xen, peth0 is the bridge
        # xen will create bridge for us, so we just do nothing
      end

      service_port = conf["worker_port"]
      puts "Writing hostname into tmp/hostname..."
      FileUtils.mkdir_p "#{RAILS_ROOT}/tmp"
      
      my_exec "hostname > #{RAILS_ROOT}/tmp/hostname"
      puts "Starting Nova worker on port #{service_port}..."

      FileUtils.mkdir_p "#{conf["run_root"]}/vm"
      FileUtils.mkdir_p "#{conf["run_root"]}/image_pool"

      unless File.exists? "#{RAILS_ROOT}/config/storage_server.conf"
        puts "!!!"
        puts "!!! You haven't initialized the worker module!"
        puts "!!! run 'rake nova:worker:init' first!"
        puts "!!!"
        exit
      end

      File.open("#{conf["run_root"]}/ftp_server_files_list_updater_lftp_script", "w") do |f|
        f.write <<LFTP_SCRIPT
set net:timeout 10
set net:max-retries 2
set net:reconnect-interval-base 1
open #{File.read "#{RAILS_ROOT}/config/storage_server.conf"}
cd /vdisks
pwd
ls
cd /agent_packages
pwd
ls
LFTP_SCRIPT
      end

      case conf["storage_type"]
      when "ftp"
        my_exec "#{RAILS_ROOT}/lib/ftp_server_files_list_updater #{RAILS_ROOT}/tmp/pids/ftp_server_files_list_updater.pid #{conf["run_root"]}"
        my_exec "#{RAILS_ROOT}/lib/image_pool_maintainer #{RAILS_ROOT}/tmp/pids/image_pool_maintainer.pid #{RAILS_ROOT}/lib/image_pool_maintainer.conf #{conf["run_root"]}/image_pool"
        my_exec "#{RAILS_ROOT}/lib/trash_cleaner #{RAILS_ROOT}/log #{conf["run_root"]} #{conf["hypervisor"]}"
      when "nfs"
        my_exec "#{RAILS_ROOT}/lib/vm_dir_cleaner.rb #{RAILS_ROOT} #{conf["run_root"]} &"
      else
        puts "[WARNING]unknown storage type :#{conf["storage_type"]}"
      end

      if conf["enable_skewness_sched"] == true
        my_exec "#{RAILS_ROOT}/lib/vm_monitor/boot.rb &"
      end

      my_exec "#{RAILS_ROOT}/lib/log_cleaner.rb &"

      log_interval = 5 # read performance meters every 5 seconds
      log_max_count = 720 # the limit on log counts. 720 * 5 sec = 1 hour
      my_exec "#{RAILS_ROOT}/lib/pm_top #{RAILS_ROOT}/tmp/pids/pm_top.pid #{RAILS_ROOT}/log/pm_top.log #{log_interval} #{log_max_count}"
      my_exec "RAILS_ENV=development #{RAILS_ROOT}/script/server -d -p #{service_port} &"
    end

    desc "Start Nova worker"
    task :start => :stop do
      do_start
    end

    def do_stop
      prepare_folders
      require_root_privilege  # worker is started using root privilege, so we have to kill it using root privilege

      conf = read_config
      # remove temp helper files
      FileUtils.rm_f "#{conf["run_root"]}/ftp_server_files_list_updater_lftp_script"
      FileUtils.rm_f "#{conf["run_root"]}/ftp_server_files_list~"
      FileUtils.rm_f "#{conf["run_root"]}/ftp_server_files_list"

      Dir.foreach("#{RAILS_ROOT}/tmp/pids") do |entry|
        next if (entry.end_with? ".pid") == false
        kill_by_pid_file "#{RAILS_ROOT}/tmp/pids/#{entry}"
      end

      Dir.foreach("#{RAILS_ROOT}/log") do |entry|
        next if (entry.end_with? ".pid") == false
        kill_by_pid_file "#{RAILS_ROOT}/log/#{entry}"
      end

      if File.exists? "#{RAILS_ROOT}/tmp/hostname"
        FileUtils.rm "#{RAILS_ROOT}/tmp/hostname"
      end

      # shutdown libvirt
      my_exec "stop libvirt-bin"
    end

    desc "Stop Nova worker"
    task :stop do
      do_stop
    end

    desc "Reset system, remove all Vmachines, cleanup all resource"
    task :reset do
      require_root_privilege

      require 'rubygems'
      require 'libvirt'
      
      my_exec "Rake nova:worker:stop"

      conf = read_config
      virt_conn_uri = nil
      case conf["hypervisor"]
      when "kvm"
        virt_conn_uri = "qemu:///system"
      when
        virt_conn_uri = "xen:///"
      else
        raise "nova:worker:reset: unsupported hypervisor #{conf["hypervisor"]}"
      end

      virt_conn = Libvirt::open(virt_conn_uri)
      virt_conn.list_defined_domains.each do |domain_name|
        puts "Destroying domain '#{domain_name}'"
        begin
          dom = virt_conn.lookup_domain_by_name domain_name
          puts "UUID=#{dom.uuid}"
          begin
            dom.destroy
          rescue
            # do nothing here
          end
          dom.undefine
        rescue
          next
        end
      end

      # TODO cleanup resource

      do_init
      do_stop
    end
  end
end

