require 'rubygems'
require 'xmlsimple'
require 'libvirt'
require 'pp'

class XController < ApplicationController

  protect_from_forgery :except => :create

  def initialize
    @conn = Libvirt::open("qemu:///system")
  end

  def list
    l = []
    @list_of_vm = []
    @conn.list_defined_domains.each {|id|
      l << @conn.lookup_domain_by_name(id) }
    l.each do |d|
      h = {}
      h[:name]  = d.name
      h[:uuid]  = d.uuid
      h[:state] = "#{ d.id} / #{d.info.state}"
      h[:cpu_time] = d.info.cpu_time
      @list_of_vm << h
    end

    l = []
    @conn.list_domains.each {|id|
      l << @conn.lookup_domain_by_id(id) }
    l.each do |d|
      h = {}
      h[:name]  = d.name
      h[:uuid]  = d.uuid
      h[:state] = "#{ d.id} / #{d.info.state}"
      h[:cpu_time] = d.info.cpu_time
      @list_of_vm << h
    end

    # todo : will be removed
    #@newvm = VmReq.new :format => 'none', :data => nil

    respond_to do |accepts|
      accepts.html
      accepts.json {render :json => @list_of_vm }
    end
  end

  def start
    begin
      d = @conn.lookup_domain_by_uuid params[:id]
    rescue
      render :text => "#{params[:id]} check fail, vm is not found.", :status => :not_found
      return
    end

    if [0,5,6].include? d.info.state
      # todo: check vnc port should be -1.
      d.create
      respond_to do |accepts|
        accepts.html {render :text => "#{params[:id]} start ok"}
        accepts.json {render :json => d.info}
      end
    else
      respond_to do |accepts|
        accepts.html {render :text => "#{params[:id]} start fail, vm(#{d.info.state}) is not stop.", :status => :conflict}
        accepts.json {render :json => d.info.to_json, :status => :conflict}
      end
    end
  end

  def stop
    begin
      d = @conn.lookup_domain_by_uuid params[:id]
    rescue
      render :text => "#{params[:id]} check fail, vm is not found.", :status => :not_found
      return
    end

    if [1,2,3].include? d.info.state
      d.shutdown
      respond_to do |accepts|
        accepts.html {render :text => "#{params[:id]} stop ok"}
        accepts.json {render :json => d.info}
      end
    else
      respond_to do |accepts|
        accepts.html {render :text => "#{params[:id]} stop fail, vm(#{d.info.state}) is not running.", :status => :conflict}
        accepts.json {render :json => d.info, :status => :conflict}
      end
    end
  end

  def suspend
    begin
      d = @conn.lookup_domain_by_uuid params[:id]
    rescue
      render :text => "#{params[:id]} check fail, vm is not found.", :status => :not_found
      return
    end

    if [1,2].include? d.info.state
      d.suspend
      respond_to do |accepts|
        accepts.html {render :text => "#{params[:id]} suspend ok"}
        accepts.json {render :json => d.info}
      end
    else
      respond_to do |accepts|
        accepts.html {render :text => "#{params[:id]} suspend fail, vm(#{d.info.state}) is not running.", :status => :conflict}
        accepts.json {render :json => d.info, :status => :conflict}
      end
    end
  end

  def resume
    begin
      d = @conn.lookup_domain_by_uuid params[:id]
    rescue
      render :text => "#{params[:id]} check fail, vm is not found.", :status => :not_found
      return
    end

    if [3].include? d.info.state
      d.suspend
      respond_to do |accepts|
        accepts.html {render :text => "#{params[:id]} resume ok"}
        accepts.json {render :json => d.info}
      end
    else
      respond_to do |accepts|
        accepts.html {render :text => "#{params[:id]} resume fail, vm(#{d.info.state}) is not suspend.", :status => :conflict}
        accepts.json {render :json => d.info, :status => :conflict}
      end
    end
  end

  def create
    # vm = Vm.new :format => params[:vm][:format], :data => params[:vm][:define]
    #d = @conn.define_domain_xml vm.getxml


    xml = REXML::Document.new params[:vm][:define]
    uuid = REXML::XPath.first xml, '/domain/uuid/text()'

    req =  Request.new
    req.kind = 'create'
    req.uuid = uuid.to_s
    begin
      req.save!
    rescue => e
      respond_to do |accepts|
        accepts.html {render :text => "create fail, because duplicated requests. #{e.message}", :status => :not_acceptable}
        accepts.json {render :json => "create fail, because duplicated requests. #{e.message}", :status => :not_acceptable}
      end
      return
    end

    begin
      prepare_storage req, xml
      puts xml
    rescue => e
      puts e
      req.destroy
      respond_to do |accepts|
        accepts.html {render :text => "create fail, because can\'t build vdisks. #{e.message}", :status => :not_acceptable}
        accepts.json {render :json => "create fail, because can\'t build vdisks'. #{e.message}", :status => :not_acceptable}
      end
      return
    end

    begin
      pp xml
      d = @conn.define_domain_xml xml.to_s
    rescue => e
      respond_to do |accepts|
        accepts.html {render :text => "define fail, #{e.message}", :status => :not_acceptable}
        accepts.json {render :json => "#{e.message}", :status => :not_acceptable}
      end
      req.destroy
      return
    end

    if params[:vm][:runow] == '1'
      begin
        d.create
      rescue => e
        respond_to do |accepts|
          accepts.html {render :text => "create fail, #{e.message}", :status => :not_acceptable}
          accepts.json {render :json => "#{e.message}", :status => :not_acceptable}
        end
        req.destroy
        return
      end
    end

    respond_to do |accepts|
      accepts.html {render :text => "#{d.uuid} create ok"}
      accepts.json {render :json => d.uuid}
    end
    req.destroy

  rescue SQLException => e
  rescue Libvirt::DefinitionError => e
  rescue Libvirt::RetrieveError => e
  rescue Libvirt::Error => e
  ensure
    req.destroy
  end

  # 察看一个虚拟机的状态：
  #    check id => domain::info
  #
  # libvirt定义的虚拟机的状态：
  #   * VIR_DOMAIN_NOSTATE  =   0  : no state
  #   * VIR_DOMAIN_RUNNING  =   1 : the domain is running
  #   * VIR_DOMAIN_BLOCKED  =   2 : the domain is blocked on resource
  #   * VIR_DOMAIN_PAUSED =   3 : the domain is paused by user
  #   * VIR_DOMAIN_SHUTDOWN =   4 : the domain is being shut down
  #   * VIR_DOMAIN_SHUTOFF  =   5 : the domain is shut off
  #   * VIR_DOMAIN_CRASHED  =   6 : the domain is crashed
  def check
    begin
      @d = @conn.lookup_domain_by_uuid params[:id]
    rescue
      render :text => "#{params[:id]} check fail, vm is not found.", :status => :not_found
      return
    end

    domain = XmlSimple.xml_in @d.xml_desc
    @port = domain['devices'][0]['graphics'][0]['port']

    respond_to do |accepts|
      accepts.html
      accepts.json {render :json => @d.info.to_json}
    end
    return
  end

  def destroy
    begin
      d = @conn.lookup_domain_by_uuid params[:id]
    rescue
      render :text => "#{params[:id]} destroy fail, vm is not found.", :status => :not_found
      return
    end

    if [1,2,3,4].include? d.info.state
      d.destroy
    end

    d.undefine
    d.free
    respond_to do |accepts|
      accepts.html {render :text => "#{params[:id]} destroy ok"}
      accepts.json {render :nothing}
    end
  end

  protected

  # 根据规格建立临时存储
  #   request, specification =>
  # 是一个hash对象，包括关键字：:src, :uuid, :size, :format等。
  # 下面这个请求通过拷贝模板建立本地存储
  #   {:src=>"copy", :uuid=>"xxx-yyy-zzz-uuuu"}
  # 下面这个请求通过新建本地存储
  #   {:src=>"new", :size=>"500m", :format=>"ext3"}
  def create_storage_for_vm(req, spec)
    puts req
    puts spec
    if spec[:src].downcase == 'copy' and spec.key?(:uuid)
      vd = S0.get spec[:uuid], req.uuid
    elsif spec[:src].downcase == 'new' and spec.key?(:size) and spec.key?(:format)
      vd = S0.create spec
    else
      fail ArgumentError, "不能识别的虚拟机存储构造类型"
    end
    puts ">>>>vd == #{ vd }"
    return vd
  end

  def prepare_storage(req, xml)
    lod = REXML::XPath.match xml, '/domain/devices/disk/source'
    lod.each do |d|
      # todo: 校验spec合法
      spec = d.attribute('file').value
      vd = create_storage_for_vm req, eval(spec)
      fail S0Error unless vd
      d.add_attribute('file', vd.filename)
    end
  end
end
