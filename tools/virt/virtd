#!/usr/bin/ruby

# check if has correct cmdline params
if ARGV.length == 0
  puts <<HELP_DOC
virtd - virt daemon
usage: virtd <working_dir>
   working_dir: the virtd pid, and running vm's info will be saved into this folder
HELP_DOC
  exit
else
  unless File::directory? ARGV[0]
    puts "error: '#{ARGV[0]}' is not a folder"
    exit
  end
end

working_dir = ARGV[0]

# check if a process is running, with the "kill -0" trick
def is_running? pid
  begin
    Process.kill(0, pid)
  rescue
    return false
  end
end

pid_file = File.join working_dir, "virtd.pid"
sock_file = File.join working_dir, "virtd.sock"

# when pid_file exists, check if virtd is already running
if File.exists? pid_file
  puts "found existsing virtd.pid file in working directory"
  File.open(pid_file, "r") do |f|
    pid = f.read.to_i
    puts "checking if virtd is running with pid=#{pid}"
    if (is_running? pid) and File.exists? sock_file
      puts "virtd is already running"
      exit
    else
      puts "virtd not running, old virtd.pid will be overwritten"
      begin
        Process.kill(9, pid) # try to kill existing process
      rescue
      end
    end
  end
end

fork do
  # forked, running as a daemon process

  if File.exists? sock_file
    # remove exsiting socket file
    File.delete sock_file
  end
  
  File.open(pid_file, "w") do |f|
    f.write(Process.pid)
  end

  require File.join(File.dirname(__FILE__), "kvm/kvm_adapter.rb")
  require 'socket'

  serv = UNIXServer.new sock_file
  puts "virtd started with pid=#{Process.pid}, sock=#{sock_file}"

  while true
    sock = serv.accept
    child_proc = fork do
      puts "new client"
      puts "TODO"

      # TODO handle client requests
      r = sock.readline
      puts r
    end
    Process.detach child_proc # prevent zombie process
  end

end

sleep 0.1 # wait for a short time, so the output could be shown clearly

