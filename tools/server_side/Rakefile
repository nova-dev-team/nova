# Rakefile for automatically generate Makefiles.
#
# Author: Santa Zhang (santa1987@gmail.com)

require 'find'

# execute a command
def my_exec cmds
  cmds.each_line do |cmd|
    cmd = cmd.strip
    puts "[cmd] #{cmd}"
    system cmd
  end
end

load "rake.gen.conf"

# the final buildable targets, used when generating 'all-xxx' targets.
# its a map (build_mode -> list of targets)
$g_targets = {}

# acceptable source code extension
$source_ext = [".c", ".cc", ".cpp", ".cxx" ]

# randomly generate a token with alphabets, like 'acd', 'zfc', etc.
def random_token length = 5
  token = ""
  alphabets = "abcdefghijklmnopqrstuvwxyz"
  1.upto(length) do |i|
    idx = rand(alphabets.length)
    token += alphabets[idx..idx]
  end
  return token
end

# Join string list. Skip empty strings.
def my_join join_str, str_list
  stripped_str_list = str_list.select {|str| str.length != 0}
  stripped_str_list.join join_str
end

# check if a source file has 'main()' function
def has_main_entry? file
  File.open(file).read =~ /^int main\(/
end

# remove the extension from file path
def drop_ext f
  ext = File.extname f
  f[0..-ext.length - 1]
end

# get the source file corresponding to a file.
# if .h was given, corresponding .c .cc .cpp .cxx file will be returned
# if .c .cc .cpp .cxx, it self will be returned
def source_file_of f
  case File.extname(f)
  when ".h"
    $source_ext.each do |ext|
      src_fn = drop_ext(f) + ext
      return src_fn if File.exists? src_fn
    end
    puts "[error] cannot find corresponding source file for '#{f}'"
  else
    return f
  end
end

# finds all depended obj file, including inherit dependency
def depended_obj file, build_mode
  visited = []
  not_visited = depended_header file
  
  loop do
    break if not_visited.length == 0
    header = not_visited[0]
    depended_header(source_file_of header).each do |h|
      (not_visited << h) if not (not_visited.include? h or visited.include? h)
    end
    not_visited.delete header
    visited << header
  end

  obj_list = visited.map do |header|
    (my_join "-", ["obj", build_mode]) + "/#{drop_ext(header)}.o"
  end
  obj_list = obj_list.sort
  obj_list = obj_list.uniq
  return obj_list
end

# finds all directly depended header files, without inherit dependency
def depended_header file
  list = []
  File.open(source_file_of file) do |src_f|
    src_f.each_line do |line|
      line = line.strip
      if line =~ /#include \"/
        header = line[10..-2]
        list.concat(all_src_files.select {|f| f.end_with? header})
      end
    end
  end
  if File.exist? drop_ext(file) + ".h"
    File.open(drop_ext(file) + ".h") do |src_f|
      src_f.each_line do |line|
        line = line.strip
        if line =~ /#include \"/
          header = line[10..-2]
          list.concat(all_src_files.select {|f| f.end_with? header})
        end
      end
    end
  end
  list = list.uniq
  list = list.sort
  return list
end

# get all build targets in a module, with a given build mode. it also sets up the final build targets
def all_targets_in_module mod, build_mode
  depend = {mod => []}
  action = {mod => []}

  all_obj_list = []
  all_bin_list = [] # all the executable file list

  Find.find(mod) do |path|
    next if FileTest.directory? path
    cc_or_cxx = nil
    cc_or_cxx_flags = nil
    ext_name = File.extname path
    if ext_name == ".c"
      # for C
      cc_or_cxx = "CC"
      cc_or_cxx_flags = "CFLAGS"
    elsif $source_ext.include? ext_name
      # for C++
      cc_or_cxx = "CXX"
      cc_or_cxx_flags = "CXXFLAGS"
    end
    if cc_or_cxx != nil
      obj_name = (my_join "-", ["obj", build_mode]) + "/#{drop_ext(path) + ".o"}"
      all_obj_list << obj_name
      if has_main_entry? path
        bin_name = (my_join "-", ["bin", build_mode]) + "/#{drop_ext(File.basename path)}"
        all_bin_list << bin_name
        depend[mod] << bin_name

        depend[bin_name] = [] if depend[bin_name] == nil
        depend[bin_name] << obj_name
        depend[bin_name].concat(depended_obj path, build_mode)

        action[bin_name] = [] if action[bin_name] == nil
        action[bin_name] << "$(#{my_join "_", [cc_or_cxx, build_mode]}) $(#{my_join "_", [cc_or_cxx_flags, build_mode]}) $(#{my_join "_", ["LDFLAGS", build_mode]}) #{obj_name} #{(depended_obj path, build_mode).join " "} -o #{bin_name}"

        # a global build target
        all_xxx = my_join "_", ["all", build_mode]
        $g_targets[all_xxx] = [] if $g_targets[all_xxx] == nil
        $g_targets[all_xxx] << bin_name
      end

      depend[mod] << obj_name

      depend[obj_name] = [] if depend[obj_name] == nil
      depend[obj_name] << path
      depend[obj_name].concat(depended_header path)

      action[obj_name] = [] if action[obj_name] == nil
      action[obj_name] << "$(#{my_join "_", [cc_or_cxx, build_mode]}) $(#{my_join "_", [cc_or_cxx_flags, build_mode]}) -c #{path} -o #{obj_name}"
    end
  end

  if defined? LIB_MODULES and LIB_MODULES.include? mod
    # make .a file
    lib_name = (my_join "-", ["bin", build_mode]) + "/lib#{mod}.a"
    depend[mod] << lib_name

    depend[lib_name] = [] if depend[lib_name] == nil
    depend[lib_name] << all_obj_list

    action[lib_name] = [] if action[lib_name] == nil
    action[lib_name] << "ar cq #{lib_name} $^"
    action[lib_name] << "ranlib #{lib_name}"
    action[lib_name] << ""

    all_xxx = my_join "_", ["all", build_mode]
    $g_targets[all_xxx] = [] if $g_targets[all_xxx] == nil
    $g_targets[all_xxx] << lib_name
  end

  if defined? TEST_MODULES and TEST_MODULES.include? mod
    # add a run#{mod} target
    run_mod = my_join "-", ["run-#{mod}", build_mode]
    depend[run_mod] = [] if depend[run_mod] == nil
    depend[run_mod] << (my_join "-", [mod, build_mode])

    action[run_mod] = [] if action[run_mod] == nil
    action[run_mod] << "@clear"

    echo_info = "Running test module \\'#{mod}\\'"
    action[run_mod] << "@echo #{echo_info}"
    action[run_mod] << "@echo #{"=" * (echo_info.length - 2)}"

    test_case_counter = 1
    all_bin_list = all_bin_list.sort
    all_bin_list.each do |e|
      echo_info =  "#{test_case_counter} of #{all_bin_list.length}: Running test case \\'#{File.basename e}\\'"
      action[run_mod] << "@echo #{echo_info}"
      action[run_mod] << "@echo #{"-" * (echo_info.length - 2)}"
      action[run_mod] << "@#{e}"
      action[run_mod] << "@echo #{"-" * (echo_info.length - 2)}"
      action[run_mod] << "@echo"
      test_case_counter += 1
    end

    all_xxx = my_join "_", ["all", build_mode]
    $g_targets[all_xxx] = [] if $g_targets[all_xxx] == nil
    $g_targets[all_xxx] += all_bin_list
  end

  content = ""
  depend.keys.sort.each do |target|
    depend[target] = depend[target].sort
    if BUILD_MODULES.include? target
      content += <<CONTENT
#{my_join "-", [target, build_mode]}: #{my_join "-", ["bin", build_mode]} #{my_join "-", ["obj", build_mode]} #{depend[target].join " "}
#{action[target].collect {|act| "\t#{act}\n"}}
CONTENT
    else
      content += <<CONTENT
#{target}: #{depend[target].join " "}
#{action[target].collect {|act| "\t#{act}\n"}}
CONTENT
    end
  end

  return content
end

# generate all targets with a certain build mode
def gen_make_targets build_mode

  # clear g_targets, because this function will be run many times
  $g_targets = {}

  content = ""
  BUILD_MODULES.sort.each do |mod|
    content += all_targets_in_module mod, build_mode
    content += "\n"
  end

  # generate build target for 'all_xxx' targets
  content += "#{my_join "-", ["all", build_mode]}: "
  content += "#{my_join "-", ["bin", build_mode]} "
  content += "#{my_join "-", ["obj", build_mode]} "
  $g_targets.keys.sort.each do |target|
    content += $g_targets[target].join(" ")
  end
  content += "\n\n"
  return content
end

# return a list of all source files (.h, .c .cc .cxx .cpp)
# like find . -iname *.h && find . -iname *.c
$g_all_src_files = nil
def all_src_files
  return $g_all_src_files if $g_all_src_files != nil
  $g_all_src_files = []
  BUILD_MODULES.sort.each do |mod|
    Find.find(mod) do |path|
      if FileTest.directory? path
        # do nothing
      elsif File.extname(path) == ".h" or $source_ext.include? File.extname(path)
        $g_all_src_files << path
      end
    end
  end
  return $g_all_src_files
end

#return a list of all directories in source folders
def mk_obj_dirs_list
  list = []
  BUILD_MODULES.sort.each do |mod|
    Find.find(mod) do |path|
      if FileTest.directory? path
        list << path
      end
    end
  end
  list = list.sort
  min_list = []
  if list.length < 2
    min_list = list
  else
    (0..(list.length - 2)).each do |idx|
      a = list[idx]
      b = list[idx + 1]
      if (b.start_with? a) == false
        min_list << a
      end
      if idx == list.length - 2
        min_list << b
      end
    end
  end
  return min_list
end

# assert that there is no duplicate file name in any folder
# note that folder1/a.c and folder2/a.c are duplicated!
def assert_no_duplicate_fname
  inverse_map = {}
  all_src_files.each do |path|
    base_name = File.basename path
    if inverse_map.has_key? base_name
      raise "Duplicate file name: '#{path}' & '#{inverse_map[base_name]}'"
    end
    inverse_map[base_name] = path
  end
end

# ensure that every source code file either has an associated .h file, or they have main() entry
def assert_src_header_pair
  flist = all_src_files
  flist.each do |path|
    if $source_ext.include? File.extname(path)
      header_path = drop_ext(path) + ".h"
      if has_main_entry? path
        # has main() entry, so there should not be a .h file
        raise "'#{path}' already have main() entry, so '#{header_path}' is not needed!" if flist.include? header_path
      else
        # does not have main() entry, so it must have a .h file
        raise "'#{path}' found, but '#{header_path}' does not exist!" unless flist.include? header_path
      end
    end
  end
end

# check if there is bad coding style
def warn_bad_style
  flist = all_src_files

  flist.each do |path|
    if defined? NO_STYLE_CHECK
      should_skip = false
      NO_STYLE_CHECK.each do |mod|
        if path.start_with? mod
          should_skip = true
          break
        end
      end
      next if should_skip
    end

    # check if used tabs in spacing
    File.open(path) do |f|
      row = 1
      f.each_line do |line|
        if line =~ /^[ ]*\t/
          puts "style warning: #{path}, #{row}: please don't use tab for spacing"
        end
        row += 1
      end
    end

    # check if has #ifndef guard
    if path.end_with? ".h"
      File.open(path) do |f|
        has_guard = false
        guard_name = nil
        f.each_line do |line|
          if guard_name == nil
            if line =~ /^\#ifndef.*_H_$/
              guard_name = line.split[-1]
            end
          else
            # last line is #ifndef, so this line must be #define
            if line =~ /^\#define/ and line.include? guard_name
              has_guard = true
              break
            else
              guard_name = nil
            end
          end

        end

        if has_guard == false
          puts "style warning: #{path}, no #ifndef guard found!"
        end
      end
    end

    # check if #endif are followed by comments
    File.open(path) do |f|
      row = 1
      f.each_line do |line|
        if line =~ /^\#endif/
          unless line.include? '//' or line.include? '/*'
            puts "style warning: #{path}:#{row}, #endif should be followed by comments!"
          end
        end
        row += 1
      end
    end

    # check if .h files have got @author, @file tags
    if path.end_with? ".h"
      has_author_tag = false
      has_file_tag = false
      File.open(path) do |f|
        f.each_line do |line|
          if line =~ /@author/
            has_author_tag = true
          end
          if line =~ /@file/
            has_file_tag = true
          end
        end
      end
      if has_author_tag == false
        puts "style warning: #{path}, does not have @author tag!"
      end
      if has_file_tag == false
        puts "style warning: #{path}, does not have @file tag"
      end
    end

    # check if there is multiple return in one function, when there is memory allocation
    File.open(path) do |f|
      inside_fun = nil
      return_rows = []
      row = 1
      has_mem_alloc = false
      f.each_line do |line|
        if line =~ /^[a-z].*\{[ \t]*$/
          inside_fun = line.strip[0..-2].strip
          return_rows = []
          has_mem_alloc = false
        elsif line =~ /^\}.*/
          inside_fun = nil
          if return_rows.size > 1 and has_mem_alloc == true
            puts "style warning: #{path}:[#{return_rows.join ", "}], multiple return statement in one function, when there is memory allocation!"
          end
          return_rows = []
          has_mem_alloc = false
        elsif inside_fun != nil
          if line =~ /^[ \t]*return .*;.*$/
            return_rows << row
          elsif line =~ /[a-z]*_new\(/ or line =~ /malloc[a-z_]*\(/
            has_mem_alloc = true
          end
        end
        row += 1
      end
    end

    # check if has trailing white space
    File.read(path).each_line do |line|
      line = line.chomp
      if line.end_with? ' ' or line.end_with? '\t'
        puts "style warning: #{path} has trailing whitespaces"
        break
      end
    end

  end
end

desc "Do style checking"
task :check do
  puts "Checking project..."
  puts "List of files to be checked:"
  all_src_files.each do |f|
    puts "  #{f}"
  end
  puts "--"
  warn_bad_style
  assert_no_duplicate_fname
  puts "No duplicate file name"
  assert_src_header_pair
  puts "All source code files either has got a .h file, or they have main() entry"
  puts "Finished checking"
end

desc "Generate Makefile"
task :gen => :check do
  puts "Generating Makefile"

  # Default build mode
  unless defined? BUILD_MODES
    puts 'warning: BUILD_MODES not defined in rake.gen.conf, using default settings'
    BUILD_MODES = {
      "" => {
        "CC" => "gcc",
        "CXX" => "g++",
        "CFLAGS" => "-Wall",
        "CXXFLAGS" => "-Wall",
        "LDFLAGS" => ""
      }
    }
  end

  mf_targets = ["clean", "targets"]
  mf_default_targets = []
  
  mf_header = <<MF_EOF
# WARNING! This file is automatically generated by "rake gen".
# WARNING! Any modification to it would be lost after another "rake gen" operation!

# Automatically generated at #{Time.now}
MF_EOF

  mf_content_linux = <<MF_EOF
MKDIR_P=mkdir -p
RMRF=rm -rf
DEL_RECURSIVE=find . -iname
DEL_RECURSIVE_OPTIONS=-delete
MF_EOF

  mf_content_mingw32 = <<MF_EOF
MKDIR_P=md
RMRF=rd /S /Q
DEL_RECURSIVE=for /r %f in
DEL_RECURSIVE_OPTIONS=do del "%f"
MF_EOF

  mf_content = <<MF_EOF
#{
BUILD_MODES.collect do |mode, settings|
  <<MODE_CONSTS
#{my_join("_", ["CC", mode])}=#{settings["CC"]}
#{my_join("_", ["CXX", mode])}=#{settings["CXX"]}
#{my_join("_", ["CFLAGS", mode])}=#{settings["CFLAGS"]} #{BUILD_MODULES.collect {|mod| "-I#{mod} "}}
#{my_join("_", ["CXXFLAGS", mode])}=#{settings["CXXFLAGS"]} #{BUILD_MODULES.collect {|mod| "-I#{mod} "}}
#{my_join("_", ["LDFLAGS", mode])}=#{settings["LDFLAGS"]}
MODE_CONSTS
end
}

#{
default_build_mode = BUILD_MODES.first[0]
if defined? DEFAULT_BUILD_MODE
  default_build_mode = DEFAULT_BUILD_MODE
end
if default_build_mode != ""
  mf_default_targets << default_build_mode
else
  mf_default_targets << (my_join '-', ['bin', default_build_mode])
  mf_default_targets << (my_join '-', ['obj', default_build_mode])
  DEFAULT_BUILD_MODULES.each do |mod|
    mf_default_targets << (my_join '-', [mod, default_build_mode])
  end
end
"default: #{mf_default_targets.join ' '}"
}

#{
BUILD_MODES.collect do |build_mode, settings|
  if build_mode != ""
    mf_targets << build_mode
    mf_targets << "all-#{build_mode}"
    "#{build_mode}: #{my_join '-', ['bin', build_mode]} #{my_join '-', ['obj', build_mode]} #{DEFAULT_BUILD_MODULES.collect {|mod| (my_join '-', [mod, build_mode]) + ' '}}\n\n"
  else
    mf_targets << "all"
  end
end
}

#{
BUILD_MODES.collect do |mode, settings|
  bin_target = my_join "-", ["bin", mode]
  <<BIN_TARGET
#{bin_target}:
	$(MKDIR_P) #{bin_target}

BIN_TARGET
end
}

#{
BUILD_MODES.collect do |mode, settings|
  obj_target = my_join "-", ["obj", mode]
  <<OBJ_TARGET
#{obj_target}:
#{mk_obj_dirs_list.collect {|dir| "\t$(MKDIR_P) #{obj_target}/#{dir}\n"}}

OBJ_TARGET
end
}

#{
if File.exists? "Doxyfile"
  # only enable "make api" when there is already an Doxyfile
  mf_targets << "api"
"api: #{all_src_files.collect {|f| f + " "}}
	doxygen
"
end
}

clean:
	$(RMRF) #{BUILD_MODES.collect {|mode, settings| (my_join "-", ["bin", mode]) + " "}}
	$(RMRF) #{BUILD_MODES.collect {|mode, settings| (my_join "-", ["obj", mode]) + " "}}
	$(RMRF) api
	$(DEL_RECURSIVE) \*.log $(DEL_RECURSIVE_OPTIONS)
	$(DEL_RECURSIVE) \*~ $(DEL_RECURSIVE_OPTIONS)

#{
BUILD_MODES.collect do |mode, settings|
  gen_make_targets mode
end
}

#{
# default test targets
default_build_mode = BUILD_MODES.first[0]
if defined? DEFAULT_BUILD_MODE
  default_build_mode = DEFAULT_BUILD_MODE
end
if defined? TEST_MODULES and default_build_mode != ""
  TEST_MODULES.collect do |mod|
    mf_targets << "run-#{mod}"
    "run-#{mod}: #{my_join "-", ["run#{mod}", default_build_mode]}\n\n"
  end
end
}

#{
default_build_mode = BUILD_MODES.first[0]
if defined? DEFAULT_BUILD_MODE
  default_build_mode = DEFAULT_BUILD_MODE
end
if default_build_mode != ""
  BUILD_MODULES.collect do |mod|
    mf_targets << mod
    "#{mod}: #{my_join "-", [mod, default_build_mode]}\n\n"
  end
end
}

#{
"include Makefile.in" if File.exists? "#{File.dirname __FILE__}/Makefile.in"
}

MF_EOF

  mf_targets.sort!
  mf_targets.uniq!
  
  mf_tail_linux = <<MF_EOF
targets:
#{
mf_targets.collect do |target|
  if mf_default_targets.include? target
    "\t@echo \"* #{target}\"\n"
  else
    "\t@echo \"  #{target}\"\n"
  end
end
}
MF_EOF

  mf_tail_mingw32 = <<MF_EOF
targets:
#{
mf_targets.collect do |target|
  if mf_default_targets.include? target
    "\t@echo * #{target}\n"
  else
    "\t@echo   #{target}\n"
  end
end
}
MF_EOF

  File.open("Makefile", "w") do |mf|
    mf.write (mf_header + mf_content_linux + mf_content + mf_tail_linux)
  end

  if defined? GEN_MINGW32_MAKEFILE and GEN_MINGW32_MAKEFILE == true
    File.open("Makefile.mingw32", "w") do |mf|
      mf.write (mf_header + mf_content_mingw32 + mf_content + mf_tail_mingw32)
    end
  end
end

desc "Show all notes like TODO, ENHANCE, etc"
task :notes do
  ["TODO", "NOTE", "ENHANCE", "XXX", "FIXME"].each do |note|
    system "grep #{note} * -r -n --color"
    puts
  end
end

task :default do
  puts "Run 'rake -T' to get list of functions"
  puts "Run 'rake gen' to generate Makefile"
end

desc "Make .tar.gz pack for source distribution"
task :tar do
  token = random_token

  project_name = File.basename(File.expand_path(File.dirname(__FILE__)))
  
  # git clone to a temp dir in '/tmp'
  clone_folder_parent = "/tmp/#{project_name}-make-tar.#{token}"
  clone_folder = "#{clone_folder_parent}/#{project_name}"
  source_root = File.dirname __FILE__

  tar_fn = "#{source_root}/#{project_name}.tar.gz"

  my_exec <<CMD
git clone #{source_root} #{clone_folder}
rm -Rf #{clone_folder}/.git
rm -f #{tar_fn}
cd #{clone_folder}/.. && tar pczf #{tar_fn} #{project_name}
rm -Rf #{clone_folder_parent}
CMD
  puts "Created #{project_name}.tar.gz in source root folder!"
end

def trim_right line
  line = line.chomp
  if (line.end_with? ' ') or (line.end_with? '\t')
    line.chop!
    return (trim_right line)
  end
  line
end

desc "Fix bad styles"
task :fix do
  puts "fixing trailing whitespaces"

  flist = all_src_files
  flist.each do |path|
    if defined? NO_STYLE_CHECK
      should_skip = false
      NO_STYLE_CHECK.each do |mod|
        if path.start_with? mod
          should_skip = true
          break
        end
      end
      next if should_skip
    end

    all_lines = File.read path
    File.open(path, "w") do |f_out|
      note_printed = false
      all_lines.each_line do |line|
        trimmed_line = trim_right(line)
        unless note_printed
          if "#{trimmed_line}\n" != line
            puts "removed trailing whitespace: #{path}"
            note_printed = true
          end
        end
        f_out.write "#{trimmed_line}\n"
      end
    end
  end

end

